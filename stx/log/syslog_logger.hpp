#ifndef STX_LOG_SYSLOG_LOGGER_HPP
#define STX_LOG_SYSLOG_LOGGER_HPP

#include <stx/log/basic_logger.hpp>

#include <syslog.h>
#include <sstream>

namespace stx {

//todo: Maybe we should add more log levels to fully support syslog priorities.
/*
    log_level_all,    
    log_level_trace,  LOG_DEBUG
    log_level_debug,  LOG_DEBUG
    log_level_info,   LOG_INFO
    log_level_warn,   LOG_WARNING / LOG_NOTICE
    log_level_error,  LOG_ERR
    log_level_fatal,  LOG_CRIT / LOG_ALERT / LOG_EMERG
    log_level_none    
*/
//  Additional log levels.
//enum {
//    log_level_alert = log_level_fatal + 1,
//    log_level_emergency
//};

template <
    class CharType,
    class Mutex = fake_mutex,
    class CharTraits = std::char_traits<CharType>,
    class Allocator = std::allocator<CharType>,
    class Formatter = log_formatter<CharType, CharTraits, Allocator>
>
class basic_syslog_logger:
    public basic_logger<CharType, Mutex, CharTraits, Allocator, Formatter>
{
public:
    
    typedef abstract_logger<Formatter, CharType, CharTraits, Allocator> abstract_logger_type;
    typedef CharType char_type;
    typedef std::basic_string<CharType, CharTraits, Allocator> string_type;
    typedef std::basic_ostream<CharType, CharTraits> ostream_type;
    typedef basic_logger<CharType, Mutex, CharTraits, Allocator, Formatter> basic_logger_type;
    typedef std::basic_ostringstream<CharType, CharTraits, Allocator> ostringstream_type;
    
    basic_syslog_logger(int log_level = log_level_all): basic_logger_type(log_level)
    {
    }
    
    //  options:
    //      LOG_PID: Log the process ID with each message. This is useful for
    //          identifying specific processes.
    //      LOG_CONS: Write messages to the system console if they cannot be
    //          sent to the logging facility. The syslog() function ensures that
    //          the process does not acquire the console as a controlling terminal
    //          in the process of writing the message.
    //      LOG_NDELAY: Open the connection to the logging facility immediately.
    //          Normally the open is delayed until the first message is logged.
    //          This is useful for programs that need to manage the order in
    //          which file descriptors are allocated.
    //      LOG_ODELAY: Delay open until syslog() is called.
    //      LOG_NOWAIT: Do not wait for child processes that may have been created
    //          during the course of logging the message. This option should be
    //          used by processes that enable notification of child termination
    //          using SIGCHLD, since syslog() may otherwise block waiting for a
    //          child whose exit status has already been collected.
    //  facility:
    //      LOG_USER: Messages generated by arbitrary processes. This is the
    //          default facility identifier if none is specified.
    //      LOG_LOCAL0: Reserved for local use.
    //      LOG_LOCAL1: Reserved for local use.
    //      LOG_LOCAL2: Reserved for local use.
    //      LOG_LOCAL3: Reserved for local use.
    //      LOG_LOCAL4: Reserved for local use.
    //      LOG_LOCAL5: Reserved for local use.
    //      LOG_LOCAL6: Reserved for local use.
    //      LOG_LOCAL7: Reserved for local use.
    basic_syslog_logger(
        const string_type& prepending_string = "",
        int options = LOG_ODELAY,
        int facility = LOG_USER,
        const string_type& delimiter = "",
        int log_level = log_level_all)
    {
        create(prepending_string, options, facility, delimiter, log_level);
    }
    
    void create(
        const string_type& prepending_string = "",
        int options = LOG_ODELAY,
        int facility = LOG_USER,
        const string_type& delimiter = "",
        int log_level = log_level_all)
    {
        basic_logger_type::level_ = log_level;
        basic_logger_type::delimiter_ = delimiter;
        openlog(prepending_string.c_str(), options, facility);
    }
    
    virtual ~basic_syslog_logger()
    {
        closelog();
    }
    
    basic_syslog_logger& set_level(int new_level)
    {
        basic_logger_type::set_level(new_level);
        setlogmask(level_to_syslog_priority(new_level));
        return *this;
    }
    
    ostream_type& stream()
    {
        ss_.str(""); //todo make portable for wchar_t
        return ss_;
    }
    
    void start_formatting(int message_level)
    {
        message_level_ = message_level;
    }
    
    void finish_formatting(Formatter& fmt)
    {
        if (fmt.enabled()) {
            stream() << std::endl;
            syslog(level_to_syslog_priority(message_level_), "%s", ss_.str().c_str());
        }
    }
    
protected:
    
    int level_to_syslog_priority(int level)
    {
        int syslog_priority = LOG_DEBUG;
        switch (level) {
        case log_level_trace: syslog_priority = LOG_DEBUG;   break;
        case log_level_debug: syslog_priority = LOG_DEBUG;   break;
        case log_level_info:  syslog_priority = LOG_INFO;    break;
        case log_level_warn:  syslog_priority = LOG_WARNING; break;
        case log_level_error: syslog_priority = LOG_DEBUG;   break;
        case log_level_fatal: syslog_priority = LOG_CRIT;    break;
        }
        return syslog_priority;
    }
    
    ostringstream_type ss_;
    int message_level_;
};

typedef basic_syslog_logger<char> syslog_logger;

} // namespace stx

#endif // STX_LOG_SYSLOG_LOGGER_HPP
